import {Meta} from '@storybook/blocks';

<Meta title="Developers / Documentation" />

# Developer documentation

This documentation is aimed at Open Formulieren-developers working on the SDK.

## Router integration and flow of data

The SDK started with react-router v5, which didn't have data routers. Since the upgrade to v6.4, we
_can_ make use of data routers, but not everything has been converted yet.

New code should maximize the use of data routers. Ideally you can do this by exporting the nested
routes in your code like so:

```jsx
export const routes = [
  {
    path: 'some-nested-path',
    element: <MyComponent />,
    // any additional data router features
  },
];
```

This implies that the element cannot take dynamic props anymore, which is the biggest draw-back.
However, there are mechanisms to load data from the route arguments via the `loader` (see the
react-router documentation). Currently we still do this manually using the `useAsync` hook.

Often you need access to the `form` object. This is now exposed via React context for the entire
application:

```jsx
const MyComponent = () => {
  const form = useFormContext();
  return (...);
};
```

## Story guidelines

Stories are written in [CSF](https://storybook.js.org/docs/react/writing-stories/introduction) and
mixed in with proze documentation, written in
[MDX](https://storybook.js.org/docs/react/writing-docs/mdx) (Markdown + JSX).

- Stories go in `<Component>.stories.js`
- Documentation goes in `<Component>.mdx`
- MDX documentation can (and should) import from the stories module.

### What to put in stories?

**Metadata**

The stories must have a default export which sets the title (and thus the location in the navbar),
component meta, decorators/parameters/argtypes relevant for all or most of the stories, e.g.:

```js
import ExampleComponent from './ExampleComponent';

export default {
  title: 'Private API / My example',
  component: ExampleComponent,
  decorators: [ConfigDecorator],
  parameters: {
    formik: {initialValues: {foo: 'bar'}},
  },
  argTypes: {
    children: {control: {disable: true}},
  },
};
```

**Stories for variants**

Often components have a number of variants that change their appearance. Definining a story ensures
that they are snapshotted in Chromatic and have visual regression testing.

Variants are not limited to appearance - they can also have differences in behaviour, which we
typically test using the `play` function too.

An example:

```jsx
export const Default = {
  name: 'Default', // optional, inferred from the exported name
  args: {
    isEnabled: true,
  },
  play: async ({canvasElement}) => {
    const canvas = within(canvasElement);
    await userEvent.click(canvas.getByRole('button'));
    // expect(something);
  };
};
```

Scan the existing stories for real usage of these patterns.

### What to put in MDX?

Any useful context/documentation for developers working with the components, or for third parties
intending to override the components (e.g. the display components for complex/smart components that
implement behaviour).

The separation between stories in CSF format and documentation in MDX is quite nice because it
allows you to document stories that you want to lock-in (through visual regression testing or
interaction testing) without cluttering the human-readable documentation. This means that you _do
not_ have to include every story in your MDX file!

Typical elements in the MDX page are:

- Meta element for storybook
- A quick summary of what the component is and does, when to use it or not
- If relevant, the existence and props of the related `Display` presentation component
- The props of the component, introspected via its `propTypes` by Storybook
- Relevant stories to illustrate some textual documentation, e.g. how validation errors are handled
  in form field components.

**Tips and tricks for the various blocks**

Storybook offers some docs to build your documentation with:

```jsx
import {ArgTypes, Canvas, Meta, Story} from '@storybook/blocks';

// stories in CSF
import MyComponent from './MyComponent';
import * as MyComponentStories from './MyComponent.stories.js';

// the actual react component
```

You need to include the meta tag, optionally with a `name` prop to give a different name in the
navbar. This ensures the documentation ends up in the right tree in the menu.

```jsx
<Meta of={MyComponentStories} name="Not Docs." />
```

Next, you can use the `Canvas` and `Story` elements. They are almost the same, except that the
`Canvas` component provides "show code" controls and the `Story` doesn't. Typically you want to have
one canvas for the component default story, so that it's clear to developers using the component how
they should call it.

Example:

```jsx
<Canvas of={MyComponentStories.Default} />
```

Finally, to document the API of the component (better known as the prop types), you should use the
`ArgTypes` block. You can feed it the entire stories meta, a particular story or (recommended) the
component itself. It introspects the component prop types and documents them. You can enrich this
more by providing docblock annotations above each prop types in your component code.

```jsx
<ArgTypes of={MyComponent} />
```

### Design tokens

Design tokens follow rougly the same pattern as MDX above, except we typically put them in a
separate docs entry: `design-tokens.mdx`. You can use the `TokensTable` from the design-token-editor
package to document the relevant design tokens.

For an example, look at the `Language Selection` component.

## Mocking in Stories

A number of components implement the API communication with the Open Forms backend. To mock these
API calls, we make use of [`msw-storybook-addon`](https://github.com/mswjs/msw-storybook-addon).

When documenting such components, it's recommended to organize the code per-component to keep
implementation, stories, mocks (and tests) close together. For example, given `MyComponent`, you
would see a folder structure like:

```
MyComponent
├── index.js
├── mocks.js
├── MyComponentDisplay.js
├── MyComponent.stories.js
└── MyComponent.mdx
```

### Known limitations

There are some known limitations related to mocking, with possible workarounds documented below.

**Dynamic mock data**

There is no dedicated add-on panel to manage mock responses. Instead, you can rely on story args to
dynamically change response data. To achieve this, you need to configure the worker as part of the
story template, for example:

```jsx
import {getWorker} from 'msw-storybook-addon';

import {myMockFactory} from './mocks';

export const worker = getWorker();

export const Template = args => {
  worker.use(myMockFactory(args.someArg));
  return <MyComponent />;
};
```

## Handling validation errors with Zod

Zod is a data parsing library which also performs validation. You use it by defining the schema that
the data should adhere to, and pass that along to `Formik`.

For invalid data, we extract the validation errors and display them at form fields. Our code sets up
a localized error map with language-specific validation messages automatically. However - there are
some accessibility issues that cannot be fixed automatically.

For a number of messages, you would ideally include additional information, e.g. for a required
field you want to display the message "You must provide a value for foo" rather than "This field is
required".

You can solve this by providing a localized error map for the specific schema, where you do have
access to this meta information. See the [Zod documentation](https://zod.dev/ERROR_HANDLING) for
more context.

An example:

```jsx
import {z} from 'zod';
import {toFormikValidationSchema} from 'zod-formik-adapter';
import {intl} from 'react-intl';

const schema = z.object({
  businessEmail: z.string().email(),
});

const MyForm = () => {
  const intl = useIntl();

  // keep a lookup table of form field name -> label, which can be translated itself
  const labels = {
    businessEmail: intl.formatMessage({description: 'field label', defaultValue: 'Business email'});
  };

  // pass a custom error map relevant to this particular form via the toFormikValidationSchema
  // parseParams
  const errorMap = (issue, ctx) => {
    switch (issue.code) {
      case z.ZodIssueCode.invalid_type: {
        if (issue.received === z.ZodParsedType.undefined) {
          const fieldName = issue.path.join('.');
          const message = intl.formatMessage({
            description: 'Required field error message',
            defaultMessage: 'You must provide a value for the {field} field.',
          }, {
            field: labels[fieldName],
          });
          return {message};
        }
      }
    }
    return {message: ctx.defaultError}; // use global schema as fallback
  };

  // render the form with the custom error map for validation
  return (
    <Formik
      initialValues={{businessEmail: ''}}
      onSubmit={console.log}
      validationSchema={toFormikValidationSchema(schema, {errorMap})}
    >
      {fields}
    </Formik>
  );
};
```
